## AQS介绍
AQS是JUC的核心。而JUC大大提高了JAVA并发性能。

* 底层数据结构是一个FIFO队列。
* 使用Node实现FIFO队列，可以用于构建锁或者其他同步装置的基础框架。
* 利用了一个int类型表示状态。
* 使用方法是继承：子类通过继承并通过实现它的方法管理其状态。

可以同时实现排他锁和共享锁模式。在使用者的角度, AQS 的功能分为两类, 独占功能 和共享功能. 
它的所有子类中要么实现并使用了它的独占功能API , 要么使用了共享锁的功能 , 不会同时使用两套API
> 它底层使用的是双向列表 ,是队列的一种实现 , 因此也可以将它当成一种队列 . 其中 Sync queue 
是同步列表 ,它是双向列表 , 包括 head ,tail 节点. 其中head 节点主要用来后续的调度 ; 
Condition queue 是单向链表 , 不是必须的 , 只有当程序中需要Condition 的时候 ,才会存在这个
单向链表 , 并且可能会有多个 Condition queue
## 实现思路
AbstractQueuedSynchronizer内部维护了一个 CLH队列来管理锁 , 线程首先会尝试获取锁 , 如果失败, 
就将当前线程及等待状态等信息包成一个NODE 节点 加入到 同步队列 (Sync queue)里 , 接着会不断循环
尝试获取锁, 它的条件是当前节点为head 的直接后继才会尝试 , 如果失败就会阻塞自己, 直到自己被唤醒,
而当持有锁的线程释放锁的时候会唤醒队列中的后继线程。

基于这些基础的设计和思路，JDK提供了许多基于AQS的子类，如CountDownLatch、Semaphore

## AQS同步组件
* CountDownLatch
* Semaphore
* CyclicBarrier
* ReentrantLock
* Condition
* FutureTask

# CountDownLatch

CountDownLatch是一个同步辅助类，通过它可以完成类似于阻塞当前线程的功能，换句话说就是一个线程或
多个线程一致等待直到其他线程执行的操作完成。CountDownLatch用了一个给定的计数器来进行初始化，
该计数器的操作是原子操作。就是同时只能有一个线程去操作该计数器。调用该类的await方法的线程会一直
处于阻塞状态，直到其他线程调用countDown方法使当前计数器的值减少到0。每次调用countDown的时候
计数器的值会减一，当计数器的值减到0的时候所有因为调用await方法而处于等待状态的线程就会继续往下
执行。这种操作只会出现一次，因为计数器是不能被重置的。如果业务上需要一个可以重置计数次数的版本可
以考虑使用`CyclicBarrier`

## 使用场景
程序执行需要等待某些条件完成后才能继续执行后续的操作，典型的应用比如说并行计算。当有一个运算量很大
的任务，我们可以将它拆分为多个子任务，等所有子任务全部完成之后，父任务再执行最后的汇总工作。

### 并发模拟
为什么并发模拟的时候可以使用CountDownLatch呢？因为我们模拟的场景是有5000个请求，每一个分别去执
行一个函数，实际的函数可以非常复杂和耗时，需要等待所有这些请求被处理完再统计结果，也就是实际请求
总数。通过CountDownLatch可以保证这些请求都被处理完才去输出最终的统计结果。过程中每一个请求都可以
看作是一个子任务。

<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbdqbjsn4rj30l40jq43e.jpg" alt="image-20200129205914986" style="zoom:60%;" />

# Semaphore
Semaphore是AQS里的同步组件，叫做信号量。并发模拟的时候可以控制并发访问的线程数。操作系统中在进程
控制方面有很大的应用。java并发库里的Semaphore可以很轻松的完成类似于操作系统中信号量的控制。它可以
很容易的控制某个资源可被同时访问的个数。和CountDownLatch使用有些类似，也是提供了两个核心方法，分
别是acquire和release。acquire方法是获取一个许可，如果没有就等待。release是在操作完成后释放一个
许可。Semaphore维护了当前访问的个数，通过提供同步机制来控制同时访问的个数。在数据结构中的链表正常
是可以保存无限个节点的，而Semaphore可以实现有限大小的列表，这里重入锁也可以实现这个功能，但是实现
上要复杂很多。

## 使用场景
Semaphore常用于仅能提供有限访问的资源，比如数据库连接数最大只有20，而上层应用并发数可能会远远大于
20，如果同时对数据库进行操作就可能出现因为无法获取数据库连接而导致异常，这时候可以通过Semaphore来
做并发访问控制。当Semaphore把并发控制到1时就跟单线程很相似。

# CyclicBarrier

![image-20200130105618676](https://tva1.sinaimg.cn/large/006tNbRwgy1gbeeigzsijj30bm0ba40s.jpg)

CyclicBarrier是AQS里的同步辅助类，它允许一组线程相互等待，直到到达某个公共的屏障点
(Common Barrier point)，通过它可以完成多个线程之间相互等待，只有当每个线程都准备就绪之后
才能继续执行后面的操作。它和CountDownLatch有些相似的地方，都是通过计数器来实现。当某个线程调用
了await方法之后，该线程就进入等待状态，而且计数器执行+1操作。当计数器的值达到我们设置的初始值之后
因为调用这个await方法进入等待状态的线程会被唤醒继续执行他们后续的操作。由于CyclicBarrier在释放
等待线程后可以重用，所以又称它为是循环屏障，可以一致循环使用。

## 使用场景
CyclicBarrier跟CountDownLatch很相似，CyclicBarrier可以用于多线程计算数据，最后合并计算结果的
应用场景，比如，用一个excel保存了所有的银行流水，excel的每一页保存了一个账户一年的每一笔银行流水，
现在需要统计日均银行流水，就可以先用多线程处理每个页里面的银行流水都执行完成之后得到每个页的日均
银行流水，之后通过CyclicBarrier action利用这些线程执行结果，计算出整个excel的日均银行流水。


## CyclicBarrier与CountDownLatch的区别
* CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset方法重置，循环使用
* CountDownLatch主要是实现一个或N个线程需要等待其他线程完成某项操作之后才能继续往下执行，它描述
的是一个或N个线程等待其他线程的关系；CyclicBarrier主要是实现了多个线程之间相互等待，直到所有线程
都满足了条件之后才能继续执行手续的操作，它描述的是各个线程内部相互等待的关系。
  - 比如启动了多个线程，每个线程如果准备好了之后就调用await方法等待，比如之前设置的屏障是5个线程，
  如果5个线程都调用了await方法，那么相当于它们都准备好了，接下来才允许它们一起往下执行
  - CyclicBarrier他能处理更复杂的业务场景。比如说，如果计算错误了可以重置计数器，并让线程们重新执行
  一次，CyclicBarrier还提供了其他有用的方法，比如说getNumberWaiting可以获取CyclicBarrier阻塞
  的线程数量，还可以通过isBroken用来知道阻塞的线程是否已经被中断了




