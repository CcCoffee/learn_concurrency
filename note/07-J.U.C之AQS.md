# AQS介绍
AQS是JUC的核心。而JUC大大提高了JAVA并发性能。

* 底层数据结构是一个FIFO队列。
* 使用Node实现FIFO队列，可以用于构建锁或者其他同步装置的基础框架。
* 利用了一个int类型表示状态。
* 使用方法是继承：子类通过继承并通过实现它的方法管理其状态。

## AQS核心思想
如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态，如果被请求的共享资源被占用，
那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。
`CLH`（Craig，Landin，and Hagersten）队列是一个虚拟的双向队列，虚拟的双向队列即不存在队列实例，仅存在节点之间的关联关系。

AbstractQueuedSynchronizer内部维护了一个 `CLH` 队列来管理锁 , 线程首先会尝试获取锁 , 如果失败, 
就将当前线程及等待状态等信息包成一个NODE 节点 加入到 `CLH`同步队列 (Sync queue)里 , 接着会不断循环
尝试获取锁, 它的条件是当前节点为head 的直接后继才会尝试 , 如果失败就会阻塞自己, 直到自己被唤醒,
而当持有锁的线程释放锁的时候会唤醒队列中的后继线程。

**AQS是将每一条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node），来实现锁的分配。**

用大白话来说，AQS就是基于`CLH`队列，用`volatile`修饰共享变量`state`，线程通过CAS去改变状态符，成功则获取锁成功，
失败则进入等待队列，等待被唤醒。

注意：**AQS是自旋锁**：在等待唤醒的时候，经常会使用自旋`（while(!cas())）`的方式，不停地尝试获取锁，直到被其他线程获取成功

它的所有子类中要么实现并使用了它的独占功能API , 要么使用了共享锁的功能 , 不会同时使用两套API
> 它底层使用的是双向列表 ,是队列的一种实现 , 因此也可以将它当成一种队列 . 其中 Sync queue 
是同步列表 ,它是双向列表 , 包括 head ,tail 节点. 其中head 节点主要用来后续的调度 ; 
Condition queue 是单向链表 , 不是必须的 , 只有当程序中需要Condition 的时候 ,才会存在这个
单向链表 , 并且可能会有多个 Condition queue
## 实现思路

![](https://img-blog.csdnimg.cn/20181128142923147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L211bGluc2VuNzc=,size_16,color_FFFFFF,t_70)
如图示，AQS维护了一个volatile int state和一个FIFO线程等待队列，多线程争用资源被阻塞的时候就会进入这个队列。
state就是共享资源，其访问方式有如下三种：
* getState();
* setState();
* compareAndSetState();

### AQS 定义了两种资源共享方式：
* 1.Exclusive：独占，只有一个线程能执行，如ReentrantLock
* 2.Share：共享，多个线程可以同时执行，如Semaphore、CountDownLatch、ReadWriteLock，CyclicBarrier

不同的自定义的同步器争用共享资源的方式也不同。可以同时实现排他锁和共享锁模式。

基于这些基础的设计和思路，JDK提供了许多基于AQS的子类，如CountDownLatch、Semaphore

### AQS底层使用了模板方法模式
同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：

* 使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）
* 将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。
这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。

自定义同步器在实现的时候只需要实现共享资源state的获取和释放方式即可，至于具体线程等待队列的维护，AQS已经在顶层实现好了。

自定义同步器实现的时候主要实现下面几种方法：
* `isHeldExclusively()`：该线程是否正在独占资源。只有用到`condition`才需要去实现它。
* `tryAcquire(int)`：独占方式。尝试获取资源，成功则返回true，失败则返回false。
* `tryRelease(int)`：独占方式。尝试释放资源，成功则返回true，失败则返回false。
* `tryAcquireShared(int)`：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。
* `tryReleaseShared(int)`：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。

### 实现举例
ReentrantLock为例，（可重入独占式锁）：state初始化为0，表示未锁定状态，A线程lock()时，
会调用tryAcquire()独占锁并将state+1.之后其他线程再想tryAcquire的时候就会失败，直到A线程unlock（）到state=0为止，
其他线程才有机会获取该锁。A释放锁之前，自己也是可以重复获取此锁（state累加），这就是可重入的概念。

> 注意：获取多少次锁就要释放多少次锁，保证state是能回到零态的。

以CountDownLatch为例，任务分N个子线程去执行，state就初始化 为N，N个线程并行执行，每个线程执行完之后countDown（）一次，
state就会CAS减一。当N子线程全部执行完毕，state=0，会unpark()主调用线程，主调用线程就会从await()函数返回，继续之后的动作。

> 一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现 `tryAcquire-tryRelease`、
`tryAcquireShared-tryReleaseShared`中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，
如ReentrantReadWriteLock。在`acquire()`, `acquireShared()`两种方式下，线程在等待队列中都是忽略中断的，
`acquireInterruptibly()`, `acquireSharedInterruptibly()`是支持响应中断的。


## AQS的简单应用
Mutex：不可重入互斥锁，锁资源（state）只有两种状态：0：未被锁定；1：锁定。
```java
class Mutex implements Lock, java.io.Serializable {
    // 自定义同步器
    private static class Sync extends AbstractQueuedSynchronizer {
        // 判断是否锁定状态
        protected boolean isHeldExclusively() {
            return getState() == 1;
        }

        // 尝试获取资源，立即返回。成功则返回true，否则false。
        public boolean tryAcquire(int acquires) {
            assert acquires == 1; // 这里限定只能为1个量
            if (compareAndSetState(0, 1)) {//state为0才设置为1，不可重入！
                setExclusiveOwnerThread(Thread.currentThread());//设置为当前线程独占资源
                return true;
            }
            return false;
        }

        // 尝试释放资源，立即返回。成功则为true，否则false。
        protected boolean tryRelease(int releases) {
            assert releases == 1; // 限定为1个量
            if (getState() == 0)//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！
                throw new IllegalMonitorStateException();
            setExclusiveOwnerThread(null);
            setState(0);//释放资源，放弃占有状态
            return true;
        }
    }

    // 真正同步类的实现都依赖继承于AQS的自定义同步器！
    private final Sync sync = new Sync();

    //lock<-->acquire。两者语义一样：获取资源，即便等待，直到成功才返回。
    public void lock() {
        sync.acquire(1);
    }

    //tryLock<-->tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。
    public boolean tryLock() {
        return sync.tryAcquire(1);
    }

    //unlock<-->release。两者语文一样：释放资源。
    public void unlock() {
        sync.release(1);
    }

    //锁是否占有状态
    public boolean isLocked() {
        return sync.isHeldExclusively();
    }
}
```


## J.U.C中使用了AQS的同步组件
* CountDownLatch
* Semaphore
* CyclicBarrier
* ReentrantLock
* Condition
* FutureTask

# CountDownLatch

CountDownLatch是一个同步辅助类，通过它可以完成类似于阻塞当前线程的功能，换句话说就是一个线程或
多个线程一致等待直到其他线程执行的操作完成。CountDownLatch用了一个给定的计数器来进行初始化，
该计数器的操作是原子操作。就是同时只能有一个线程去操作该计数器。调用该类的await方法的线程会一直
处于阻塞状态，直到其他线程调用countDown方法使当前计数器的值减少到0。每次调用countDown的时候
计数器的值会减一，当计数器的值减到0的时候所有因为调用await方法而处于等待状态的线程就会继续往下
执行。这种操作只会出现一次，因为计数器是不能被重置的。如果业务上需要一个可以重置计数次数的版本可
以考虑使用`CyclicBarrier`

## 使用场景
程序执行需要等待某些条件完成后才能继续执行后续的操作，典型的应用比如说并行计算。当有一个运算量很大
的任务，我们可以将它拆分为多个子任务，等所有子任务全部完成之后，父任务再执行最后的汇总工作。

### 并发模拟
为什么并发模拟的时候可以使用CountDownLatch呢？因为我们模拟的场景是有5000个请求，每一个分别去执
行一个函数，实际的函数可以非常复杂和耗时，需要等待所有这些请求被处理完再统计结果，也就是实际请求
总数。通过CountDownLatch可以保证这些请求都被处理完才去输出最终的统计结果。过程中每一个请求都可以
看作是一个子任务。

<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gbdqbjsn4rj30l40jq43e.jpg" alt="image-20200129205914986" style="zoom:60%;" />

# Semaphore
Semaphore是AQS里的同步组件，叫做信号量。并发模拟的时候可以控制并发访问的线程数。操作系统中在进程
控制方面有很大的应用。java并发库里的Semaphore可以很轻松的完成类似于操作系统中信号量的控制。它可以
很容易的控制某个资源可被同时访问的个数。和CountDownLatch使用有些类似，也是提供了两个核心方法，分
别是acquire和release。acquire方法是获取一个许可，如果没有就等待。release是在操作完成后释放一个
许可。Semaphore维护了当前访问的个数，通过提供同步机制来控制同时访问的个数。在数据结构中的链表正常
是可以保存无限个节点的，而Semaphore可以实现有限大小的列表，这里重入锁也可以实现这个功能，但是实现
上要复杂很多。

## 使用场景
Semaphore常用于仅能提供有限访问的资源，比如数据库连接数最大只有20，而上层应用并发数可能会远远大于
20，如果同时对数据库进行操作就可能出现因为无法获取数据库连接而导致异常，这时候可以通过Semaphore来
做并发访问控制。当Semaphore把并发控制到1时就跟单线程很相似。

# CyclicBarrier

![image-20200130105618676](https://tva1.sinaimg.cn/large/006tNbRwgy1gbeeigzsijj30bm0ba40s.jpg)

CyclicBarrier是AQS里的同步辅助类，它允许一组线程相互等待，直到到达某个公共的屏障点
(Common Barrier point)，通过它可以完成多个线程之间相互等待，只有当每个线程都准备就绪之后
才能继续执行后面的操作。它和CountDownLatch有些相似的地方，都是通过计数器来实现。当某个线程调用
了await方法之后，该线程就进入等待状态，而且计数器执行+1操作。当计数器的值达到我们设置的初始值之后
因为调用这个await方法进入等待状态的线程会被唤醒继续执行他们后续的操作。由于CyclicBarrier在释放
等待线程后可以重用，所以又称它为是循环屏障，可以一致循环使用。

## 使用场景
CyclicBarrier跟CountDownLatch很相似，CyclicBarrier可以用于多线程计算数据，最后合并计算结果的
应用场景，比如，用一个excel保存了所有的银行流水，excel的每一页保存了一个账户一年的每一笔银行流水，
现在需要统计日均银行流水，就可以先用多线程处理每个页里面的银行流水都执行完成之后得到每个页的日均
银行流水，之后通过CyclicBarrier action利用这些线程执行结果，计算出整个excel的日均银行流水。


## CyclicBarrier与CountDownLatch的区别
* CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset方法重置，循环使用
* CountDownLatch主要是实现一个或N个线程需要等待其他线程完成某项操作之后才能继续往下执行，它描述
的是一个或N个线程等待其他线程的关系；CyclicBarrier主要是实现了多个线程之间相互等待，直到所有线程
都满足了条件之后才能继续执行手续的操作，它描述的是各个线程内部相互等待的关系。
  - 比如启动了多个线程，每个线程如果准备好了之后就调用await方法等待，比如之前设置的屏障是5个线程，
  如果5个线程都调用了await方法，那么相当于它们都准备好了，接下来才允许它们一起往下执行
  - CyclicBarrier他能处理更复杂的业务场景。比如说，如果计算错误了可以重置计数器，并让线程们重新执行
  一次，CyclicBarrier还提供了其他有用的方法，比如说getNumberWaiting可以获取CyclicBarrier阻塞
  的线程数量，还可以通过isBroken用来知道阻塞的线程是否已经被中断了

# ReentrantLock与锁

java主要分两类锁，一类是synchronized关键字修饰的锁，一类是J.U.C提供的锁。J.U.C里核心的锁就是
ReentrantLock。ReentrantLock核心方法是lock与unlock。其他提供的很多方法是其灵活性的原因

## ReentrantLock与synchronized区别
* 可重入性 : ReentrantLock是可重入锁，实际上synchronized关键字修饰的锁也是可重入的。两种区别
不大，都是同一个线程进入一次锁的计数器就自增一，所以要等到锁的计数器下降为零时才能释放锁。
* 锁的实现 : synchronized关键字是依赖于JVM实现的，而ReentrantLock是JDK实现的。类似于操作系统
来控制实现和用户自己代码实现的区别。ReentrantLock可以通过阅读源码来知道具体实现，synchronized
则很难。
* 性能的区别 : 在synchronized关键字优化以前synchronized的性能比ReentrantLock差很多，但是自从
它引入来偏向锁轻量级锁（也就是自旋锁）后它们两者的性能就差不多了。在两种方法都可用的情况下，官方更
建议使用synchronized，因为它的写法更容易。其实synchronized优化感觉像借鉴了ReentrantLock中的
CAS计数。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。
* 功能区别
  - 便利性 : 很明显synchronized的使用比较方便简洁，并且它是由编译器去保证锁的加锁和释放的。而
  ReentrantLock需要我们手动声明来加锁和释放锁。为了避免忘记手动释放锁造成死锁，所以最好是在finally
  中声明释放锁。
  - 锁的细粒度与灵活度 : ReentrantLock优于synchronized
* ReentrantLock独有的功能
  - 可指定是公平锁还是非公平锁，synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得
  锁
  - 提供了一个Condition类，可以分组唤醒需要唤醒的线程，而不是像synchronized要么随机唤醒一个
  线程，要么唤醒全部线程。
  - 提供能够中断等待锁的线程的机制，通过lock.lockInterruptibly()实现这个机制。ReentrantLock
  实现是一种自旋锁，通过循环调用CAS操作来实现加锁，它的性能比较好也是因为避免了使线程进入内核态
  阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去理解和分析所设计的关键钥匙。
## 使用场景
如果需要实现ReentrantLock三个独有功能的时候必须使用ReentrantLock，其它情况下可以根据性能或者
当时的业务场景来选择使用ReentrantLock还是synchronized，通过介绍我们知道ReentrantLock相对
synchronized来说synchronized能做的事情ReentrantLock都能做，而ReentrantLock能做的synchronized
却有很多做不了。性能方面ReentrantLock也不必synchronized差。那么需不需要抛弃synchronized呢？
java.util.concurrent.locks包中的锁定类是用于高级用户和高级情况的工具，一般来说除非你对lock的
某个高级特性有明确的需要，或者有明确的证据，不仅仅是怀疑，表明在特定的情况下同步已经成为可伸缩性的
瓶颈的时候，否则建议还是继续使用synchronized，即使对于这些高级锁定的类来说synchronized仍然有
一些优势，比如在使用synchronized的时候不可能忘记释放锁，在退出synchronized块的时候JVM会为你做
这些事情，你会很容易忘记用finally去释放锁，这对程序非常有害。程序即使能够通过测试，但会在实际工作
中出现死锁，那时候会很难指出原因，这也是不是很建议初级开发人员使用lock的好理由。另外的一个原因是
因为JVM用synchronized管理锁定请求和释放时，JVM在生成线程转储时能够包括锁定信息，这对调试非常有
价值，因为他们能标示死锁或者其他异常行为的来源。而lock类其实只是普通的类，JVM不知道具体哪一个线程
拥有lock对象，而且几乎每个开发人员都熟悉synchronized，它可以在JVM的所有版本中工作，在JDK5.0成为
标准之前，使用lock类就意味着要利用特性而不是每个JVM都有的，而且不是每个开发人员都熟悉的。在实际项目
中大家遇到的需要加锁的情景其实大部分都可以使用synchronized来解决。

## 其他方法
* lockInterruptibly() : 如果当前线程没有被中断那么就获取锁定，如果已经被中断了，就抛出异常。
* isLock() : 查询此锁定是否由任意线程保持
* isHeldByCurrentThread() : 查询当前线程是否保持锁定状态
* isFair() : 是否公平锁
* hasQueuedThread : 查询指定线程是否在等待获取此锁定
* hasQueuedThreads : 查询是否有线程正在等待获取此锁定
* getHoldCount() : 查询当前线程保持锁定的个数，也就是调用lock方法的个数

## 公平锁与非公平锁的区别

请参考 [一张图读懂非公平锁与公平锁](https://www.jianshu.com/p/f584799f1c77)

1、若在释放锁的时候总是没有新的兔子来打扰，则非公平锁等于公平锁；

2、若释放锁的时候，正好一个兔子来喝水，而此时位于队列头的兔子还没有被唤醒（因为线程上下文切换是需要不少开销的），此时后来的兔子则优先获得锁，成功打破公平，成为非公平锁；

# ReentrantReadWriteLock
它里面有两个锁，一个读锁，一个写锁。
在没有任何读写锁的时候才可以取得写入锁。它可以用于实现了悲观读取，即如果我们执行中
进行读取时经常有另外一个线程需要写入的需求。为了保证同步ReentrantReadWriteLock
的读取锁定就可以派上用场。然而如果读取执行情况很多、写入很少的情况下使用
ReentrantReadWriteLock可能会使写入线程遭遇饥饿，也就是写入线程迟迟无法竞争到锁定
而一致处于等待状态。

# StampedLock
Java 8 引入了一个新的读写锁叫StampedLock. StampedLock控制锁有三种模式，独占写、悲观读、乐观读。
StampedLock的状态是由版本和模式两个部分组成。锁的获取方法返回的是一个数字作为票据。它用相应的
锁状态来表示并控制相关的访问。数字0表示没有写锁被授权访问。在读锁上分为悲观锁和乐观锁。

所谓乐观读其实也就是如果读的操作很多，写的操作很少的情况下可以乐观的认为写入与读取同时发生的几率
很少，因此不悲观的使用会完全读取锁定的悲观锁。不仅这个锁更快，而且它提供强大的乐观锁API，
这意味着你能以一个较低的代价获得一个读锁, 在这段时间希望没有写操作发生，当这段时间完成后，
你可以查询一下锁，看是否在刚才这段时间是否有写操作发生,然后你可以决定是否需要再试一次或升
级锁或放弃。

# Condition
Condition是多线程间协调通讯的工具类，使得某个或者某个线程一起等待某个条件，只有当该条件具备这些
等待的线程才会被唤醒。这里的具备条件就是我们得到的信号和重新获取锁。发送信号包含signalALl还是signal的
方法。这些等待的线程

# 互斥锁（互斥量）的开销
互斥锁的开销主要在内核态与用户态的切换。

申请锁时，从用户态进入内核态，申请到后从内核态返回用户态（两次切换）；
没有申请到时阻塞睡眠在内核态。使用完资源后释放锁，从用户态进入内核态，唤醒阻塞等待锁的进程，返回用户态（又两次切换）；
被唤醒进程在内核态申请到锁，返回用户态（可能其他申请锁的进程又要阻塞）。所以，使用一次锁，包括申请，持有到释放，当前进程要进行四次用户态与内核态的切换。
同时，其他竞争锁的进程在这个过程中也要进行一次切换。

进程上下文切换的直接消耗包括CPU寄存器保存和加载，需要调度时有内核调度代码的执行。

# 总结
* 当只有少量竞争者的时候synchronized是一个很好的通用的锁实现。
* 竞争者不少，但是它线程增长的趋势是能够预估的，这时候ReentrantLock是一个很好的通用的锁
实现。
> 在使用锁的时候一定不是看哪个锁高级就用哪一个，适合自己的使用场景的才是最关键的。这里尤其
需要注意的是synchronized不会引发死锁，JVM会自动解锁。而其他的锁如果使用不当是有可能造成
死锁的，因为有可能在某些情况下没有执行unlock操作。

转载与部分参考 :
* [AQS详解（面试）](https://blog.csdn.net/mulinsen77/article/details/84583716), by 木霖森77
* [一张图读懂非公平锁与公平锁](https://www.jianshu.com/p/f584799f1c77), by 徐志毅
* [锁开销和上下文切换开销](https://blog.csdn.net/gettogetto/article/details/74629805), by gettogetto