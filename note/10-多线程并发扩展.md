# 死锁
## 产生死锁的原因：
* 因为系统资源不足。
* 进程运行推进的顺序不合适。
* 资源分配不当等。

如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则
就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。
## 必要条件
* 互斥条件 : 线程对所分配的资源进行排他性的使用，即在一段时间内某资源只有一个线程占用，如果此时
还有其他线程要占用资源那么只能等待，直到占有资源的线程释放锁
* 请求和保持条件 : 指线程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他线程所
占用，此时请求线程阻塞，但又对自己的或其他资源保持不放
* 不剥夺条件 : 线程已获得资源在未使用完之前不被被剥夺锁，只能在使用完时自己释放
* 环路等待条件 : 若干线程之间形成一种头尾相接的循环等待资源关系。

## 避免死锁的3种办法
### 加锁顺序
线程一定要按照一定的顺序去加锁，如果线程1先对lock1加锁，再对lock2加锁。线程2先对lock2加锁，再
对lock1加锁就会造成死锁。需要代码来保证同时对lock1加锁或者同时对lock2加锁才可以。
### 加锁实现
系统在尝试获取锁的时候可以加上一个时限，超过这个时间就放弃该锁的请求，并释放自己占有的锁。在线程1
占用lock1时可以不使用synchronized关键字而使用ReentrantLock，它支持加锁给定超时时间。lock2也
换成带时限的获取锁方法。假设线程1和线程2出现相互等待的时候也会因为超时放弃锁
### 死锁检测
死锁检测实际上难以实现，通常不会有人写代码去做死锁检测。它是一种比较好的死锁预防的机制，它主要是
针对那些不可能实现按序加锁并且锁超时也不可行的场景，每当一个线程获得一个锁会在线程或锁相关的数据
结构（map、graph等等）中记下来，除此之外每当有线程请求锁也需要记录下数据结构中

当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。例如，线程A请求锁7，但是
锁7这个时候被线程B持有，这时线程A就可以检查一下线程B是否已经请求了线程A当前所持有的锁。如果线程
B确实有这样的请求，那么就是发生了死锁（线程A拥有锁1，请求锁7；线程B拥有锁7，请求锁1）。

当然，死锁一般要比两个线程互相持有对方的锁这种情况要复杂的多。线程A等待线程B，线程B等待线程C，线
程C等待线程D，线程D又在等待线程A。线程A为了检测死锁，它需要递进地检测所有被B请求的锁。从线程B所请
求的锁开始，线程A找到了线程C，然后又找到了线程D，发现线程D请求的锁被线程A自己持有着。这是它就知道
发生了死锁。

下面是一幅关于四个线程（A,B,C和D）之间锁占有和请求的关系图。像这样的数据结构就可以被用来检测死锁。

![image-20200131141545000](https://tva1.sinaimg.cn/large/006tNbRwgy1gbfpwac6rij306909v74j.jpg)

#### 那么当检测出死锁时，这些线程该做些什么呢？

一个可行的做法是释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的
是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞
争同一批锁，它们还是会重复地死锁（编者注：原因同超时类似，不能从根本上减轻竞争）。

一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保
持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这
个问题，可以在死锁发生的时候设置随机的优先级

# 多线程并发最佳实践
## 使用本地变量
尽量使用本地变量，而不是创建一个类或实例的变量。

## 使用不可变类
String、Integer等。不可变类可以降低代码中需要的同步数量。

## 最小化锁的作用域范围：S=1/(1-a+a/n)
a：并行计算部分所占比例

n：并行处理结点个数

S：加速比

当1-a等于0时，没有串行只有并行，最大加速比 S=n

当a=0时，只有串行没有并行，最小加速比 S = 1

当n→∞时，极限加速比 s→ 1/（1-a）

例如，若串行代码占整个代码的25%，则并行处理的总体性能不可能超过4。

该公式称为："阿姆达尔定律"或"安达尔定理"。

## 使用线程池的Executor，而不是直接new  Thread 执行
创建一个线程的代价是昂贵的，如果要创建一个可伸缩的Java应用，那么你需要使用线程池。

## 宁可使用同步也不要使用线程的wait和notify
从Java1.5以后，增加了许多同步工具，如：CountDownLatch、CyclicBarrier、Semaphore等，应该优
先使用这些同步工具。

## 使用BlockingQueue实现生产-消费模式
阻塞队列不仅可以处理单个生产、单个消费，也可以处理多个生产和消费。

## 使用并发集合而不是加了锁的同步集合
Java提供了下面几种并发集合框架：

ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet、ConcurrentLinkedQueue 、
ConcurrentLinkedDeque等（相关介绍请见Java 并发编程（九）并发集合框架）

## 使用Semaphore创建有界的访问
为了建立稳定可靠的系统，对于数据库、文件系统和socket等资源必须要做有机的访问，Semaphore可以限制
这些资源开销的选择，Semaphore可以以最低的代价阻塞线程等待，可以通过Semaphore来控制同时访问指定
资源的线程数。

## 宁可使用同步代码块，也不使用同步的方法
主要针对synchronized关键字。使用synchronized关键字同步代码块只会锁定一个对象，而不会将整个方法
锁定。如果更改共同的变量或类的字段，首先应该选择的是原子型变量，然后使用volatile。如果需要互斥锁，
可以考虑使用ReentrantLock。

## 避免使用静态变量
静态变量在并发执行环境下会制造很多问题，如果必须使用静态变量，那么优先是它成为final变量，如果用来
保存集合collection，那么可以考虑使用只读集合，否则一定要做特别多的同步处理和并发处理操作。