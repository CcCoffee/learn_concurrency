# 躲避并发的方式
* 设计成不可变对象
* 线程封闭
# 线程封闭
大多数的并发问题仅发生在我们想要在线程之间共享可变变量或可变状态时。如果在多个线程
之间操作共享变量，则所有线程都将能够读取和修改变量的值，从而出现意外或不正确的结果。
一种简单的避免此问题的方式是**不在线程之间共享数据**(比如只要一个线程内读写变量)。
这种技术称为线程封闭，是在我们的应用程序中实现线程安全的最简单方法之一。

当**将某个对象封闭在一个线程中时，只有这一个线程能够看到这个对象。此时即使被封闭的对象本身
不不是线程安全的**，也不会出现任何线程安全方面的问题了。因为只能被一个线程进行访问。

在Java语言中并没有强制规定某个变量必须由锁来保护， 同样在Java语言中也无法强制将对象
封闭在某个线程中。线程封闭是在程序设计中的一个考虑因素， 必须在程序中实现。Java语言
及其核心库提供了一些机制来帮助维持线程封闭性，例如局部变量和ThreadLocal类，但即便如此， 
程序员仍然需要负责确保封闭在线程中的对象不会从线程中逸出。

# 几种类型的线程封闭
* Ad-Hoc 线程封闭 : 程序控制实现，非常脆弱，最糟糕
* 栈封闭 : 局部变量，多个线程访问一个方法时，方法中的局部变量都会被拷贝一份到线程栈中，
所以局部变量不会被多个线程锁共享，无并发问题
* ThreadLocal线程封闭 : 特别好的封闭方法

## 1. Ad-Hoc 线程封闭
### 单个线程内读写对象
Ad-hoc 线程封闭描述了线程封闭的方式，由开发人员或从事该项目的开发人员确保
仅在单个线程内使用此对象。 即**维护线程封闭性的职责完全由程序实现来承担**。
这种方式方法是非常脆弱的，可用性不高，在大多数情况下应该避免。
### volatile 变量仅从单个线程写入
Ad-hoc 线程封闭下的一个特例适用于 volatile 变量。 只要确保 volatile 
变量仅从单个线程写入，就可以安全地对共享 volatile 变量执读 - 改 - 写操作。
在这种情况下，您将修改限制在单个线程以防止竞争条件，并且 volatile 变量的
可见性保证确保其他线程看到最新值。
*  volatile保证了可见性，原子性由仅由单个线程写入的限制条件来保证。
* 当决定使用线程封闭技术时， 通常是因为要**将某个特定的子系统实现为一个单线程子系统**
（如JDBC的Connection对象）。在某些情况下，单线程子系统提供的简便性要胜过
Ad-hoc线程封闭技术的脆弱性。

> 由于 Ad-hoc线程封闭技术的脆弱性， 因此在程序中尽量少用它，在可能的情况下，
应该使用更强的线程封闭技术（例如，栈封闭或ThreadLocal类）。
### 常见应用场景
常见应用是JDBC(Java Database Connectivity)的Connection对象。
JDBC规范并不要求Connection对象必须是线程安全的。在典型的服务器应用程序中， 
线程从连接池中获得一个Connection对象， 并且用该对象来处理请求， 使用完后再将对象返
还给连接池。由于大多数请求（例如Servlet请求或EJB调用等） 都是由单个线程采用同步的方
式来处理， 并且在Connection对象返回之前， 连接池不会再将它分配给其他线程， 因此， 
这种连接管理模式在处理请求时隐含地将Connection对象封闭在线程中。

## 2. 栈封闭（局部变量）
栈限制是线程封闭的一种特例，只能通过局部变量才可以访问对象，局部使对象限制
在执行线程中，存在于执行线程栈，其他线程无法访问这个栈，从而确保线程安全。
（每一个线程都有一个工作内存，工作内存中班包括有栈，局部的基本类型变量是处于栈中，
引用类型的引用处于栈中，而引用指向的对象处于堆中）。 
栈限制的例子如下：
<img src="http://dl2.iteye.com/upload/attachment/0127/9319/c1dd09ad-af15-3ff1-8a8d-a029b1907f71.png" alt="image-20200124224031757" style="zoom:70%;" />

要理解栈封闭，需要先了解多线程之间有哪些共享的数据，有哪些不共享的数据
> 能用局部变量就不用全局变量，全局变量（不是全局常量）容易引起并发问题

### 多线程的数据共享机制

同一进程间的线程究竟共享哪些资源呢，而又各自独享哪些资源呢？
- 共享的资源有
    * 堆  由于堆是在进程空间中开辟出来的，所以它是理所当然地被共享的；
    因此new出来的都是共享的（16位平台上分全局堆和局部堆，局部堆是独享的）
    * 全局变量 它是与具体某一函数无关的，所以也与特定线程无关；因此也是共享的
    * 静态变量 虽然对于局部变量来说，它在代码中是“放”在某一函数中的，
    但是其存放位置和全局变量一样，存于堆中开辟的.bss和.data段，是共享的
    * 文件等公用资源  这个是共享的，使用这些公共资源的线程必须同步。
    Win32 提供了几种同步资源的方式，包括信号、临界区、事件和互斥体。
- 独享的资源有
    * 栈 栈是独享的
    * 寄存器  这个可能会误解，因为电脑的寄存器是物理的，每个线程去取值
    难道不一样吗？其实线程里存放的是副本，包括程序计数器PC

因此，TreeSet对象的引用保存在animal变量中，animal又是一个局部变量。
局部变量保存在栈上，每个线程独享栈。因此，不同线程的栈不同，不同线程就无法
操作同时操作同一个TreeSet对象，因此保证了安全性

### 常见应用场景
#### 线程不安全的类与写法
StringBuilder是线程不安全的类，StringBuffer是线程安全的类。由于StringBuffer
所有修改方法都加上了synchronized关键字，性能有损耗，因此如果在做字符串拼接
涉及到多线程的时候可以考虑使用StringBuffer处理。但是如果是在方法里面
单独定义了一个StringBuilder的局部变量进行字符串拼接由于栈封闭也是线程安全的，
此时不会使用buffer，优先选择性能更好的StringBuilder。

## 3. ThreadLocal
ThreadLocal内部维护了一个Map，内部的key时每个线程的名称，而Map的值就是要线程封闭的
对象。每一个线程中的对象都对应着一个map中的值，也就是ThreadLocal利用Map实现对象的线程
封闭。
ThreadLocal允许我们将每个线程 ID 与相应对象的值相关联。 它允许我们为不同的
线程存储不同的对象，并维护哪个对象对应于哪个线程。它有 set 和 get 方法，
这些方法为使用它的每个线程维护一个单独的 value 副本。get() 方法总是返回从当前
正在执行的线程传递给 set()的最新值。

### 常见应用场景
#### 使用ThreadLocal保存用户信息
LoginFilter+ThreadLocal。在例如service中可以
随时随地安全取出对应用户。如果不通过这种方式，我们就需要从Controller层不停的往
下传递用户Id，导致代码不良好。

> 参考 : https://dzone.com/articles/java-concurrency-thread-confinement
https://www.iteye.com/blog/542255641-2400917
#### 不安全的SimpleDateFormat
SimpleDateFormat内部使用Calender对象进行日期操作，而Calendar内部存储的日期数据的全局变量
field，time等都是不安全的，更重要的Calendar内部函数操作对变量操作是不具有原子性的操作。
例如ThreadB执行parse时会将ThreadA执行parse时的filed数组中间结果清空。

1）每个线程使用时，都new一个SimpleDateFormat的实例，这保证每个线程都用各自的Calendar实例。
这种方式缺点：每个线程都 new 一个对象，并且使用后由于没有其它引用，都需要被回收，开销比较大。

2）可以使用ReentrantLock、Synchronized等进行同步。
使用了同步锁，意味着多线程下会竞争锁，在高并发情况下会导致系统响应性能下降。

3）使用ThreadLocal，这样每个线程只需要使用一个SimpleDateFormat实例，在多线程下比第一种
节省了对象的销毁开销，并且不需要对多线程进行同步。见DateFormatByThreadLocal

4）使用joda-time第三方依赖提供的DateTimeFormatter。见DateFormatByJodaTime

详见 ：https://www.cnblogs.com/yy3b2007com/p/11360895.html