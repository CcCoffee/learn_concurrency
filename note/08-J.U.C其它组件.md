# FutureTask
FutureTask不是AQS的子类，但是这个类对线程结果的处理值得在项目中使用。
## 创建一个线程的两种方式
* 直接继承Thread
* 实现Runnable接口
> 它们的共同缺陷是在执行完任务完成之后无法获取任务执行结果。
从java1.5开始就提供了Callable和Future，通过他们可以在任务执行完毕之后得到任务执行的结果。

## Callable与Runnable接口对比
Runnable代码非常简单，只有一个方法就是run。
Callable代码也非常简单，不同的是它是范型的接口。它里面有一个call函数，call函数的返回类型
就是我们创建callable传进入类型。callable与Runnable的功能大致相似Callable功能更强大一些，
主要是线程执行之后可以有返回值，并且可以抛出异常。

## Future接口
在Java中，如果需要设定代码执行的最长时间，即超时，可以用Java线程池ExecutorService类配合
Future接口来实现。 Future接口是Java标准API的一部分，在java.util.concurrent包中。
Future接口是Java线程Future模式的实现，可以来进行异步计算。

### Future模式
可以这样来描述：我有一个任务，提交给了Future，Future替我完成这个任务。期间我自己可以去做
任何想做的事情。一段时间之后，我就便可以从Future那儿取出结果。就相当于下了一张订货单，
一段时间后可以拿着提订单来提货，这期间可以干别的任何事情。其中Future 接口就是订货单，
真正处理订单的是Executor类，它根据Future接口的要求来生产产品。

Future接口提供方法来检测任务是否被执行完，等待任务执行完获得结果，也可以设置任务执行的超时时间。这个设置超时的方法就是实现Java程序执行超时的关键。

Future接口是一个泛型接口，严格的格式应该是Future<V>，其中V代表了Future执行的任务返回值的类型。 Future接口的方法介绍如下：
```java
interface Future {
    boolean cancel (boolean mayInterruptIfRunning); //取消任务的执行。参数指定是否立即中断任务执行，或者等等任务结束
    boolean isCancelled(); //任务是否已经取消，任务正常完成前将其取消，则返回 true
    boolean isDone();// 任务是否已经完成。需要注意的是如果任务正常终止、异常或取消，都将返回true
    V get() throws InterruptedException,ExecutionException; //等待任务执行结束，然后获得V类型的结果。InterruptedException 线程被中断异常， ExecutionException任务执行异常，如果任务被取消，还会抛出CancellationException
    V get (long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;// 同上面的get功能一样，多了设置超时时间。参数timeout指定超时时间，uint指定时间的单位，在枚举类TimeUnit中有相关的定义。如果计算超时，将抛出TimeoutException
}
```

## FutureTask
FutureTask的父类是RunnableFuture，而RunnableFuture继承了Runnable和Future着两个接口。
由此可知，FutureTask最终也是执行Callable类型的任务，如果构造函数参数是Runnable的话它会
转换成Callable类型。FutureTask实现了两个接口，所以它既可以作为Runnable被线程执行，又可以
作为Future作为Callable的返回值。
### 那么这个组合的使用有什么好处呢？
假设有一个很费事的逻辑需要计算并且返回这个值，同时这个值又不是马上需要，那么就可以使用这种组合。
用另外一个线程去计算返回值，而当前线程呢在使用这个返回值之前可以做其他的操作，等到需要这个返回值
时再通过Future得到。

# Fork/Join框架
![image-20200130215722130](https://tva1.sinaimg.cn/large/006tNbRwgy1gbexmbx16rj30bq0a8n02.jpg)

类似于map reduce。
工作原理是使用了工作窃取算法，某个线程从其他队列窃取任务来执行。
## 使用工作窃取算法的原因
加入需要做一个比较大的任务，我们可以把这个任务分割成若干个互不依赖的子任务，为了节省线程间的
竞争，由于把这些子任务分别放到不同的队列里，为每个队列创建一个单独的线程来执行队列里的任务。
线程和队列一一对应，有的线程会先把自己队列里的任务执行完，而其他线程对应的队列还有任务等待
处理，于是空闲的线程会去其他线程里的队列窃取一个任务来执行，而在这时他们会访问同一个队列，所以
为了减少窃取任务线程和被窃取任务线程之间的竞争，通常会使用的是双端队列，被窃取任务的线程永远从
双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部窃取任务执行。这个优点就是充分
利用线程进行并行计算，并减少了线程之间的竞争。缺点是在某些情况下，还是存在竞争，比如双端队列
只有一个任务时，同时这样还消耗了更多系统资源，比如创建了多个线程，有多个双端队列。对于Fork/Join
框架而言，当一个任务正在等待它使用Join操作创建的子任务结束时，执行这个任务的工作线程查找其他
未被执行的任务并开始它的执行，通过这种方式线程充分利用他们的运行时间来提高应用程序的性能。

## 局限性
* 任务只能使用Fork和Join操作来作为同步机制，如果使用了其他同步的机制，那么他们在进行
同步操作时工作线程就不能执行其他任务了，比如在Fork/Join框架中你使任务进行了睡眠，那么
在这个睡眠期间内正在执行这个任务的工作线程就不能执行其他任务了。
* 任务不应该去执行IO操作，如读写数据文件，
* 任务不能抛出检查异常

# BlockingQueue
BlockingQueue不光实现了一个完整队列所具有的基本功能，同时在多线程环境下它还自动管理了多线程
间的自动等待、唤醒功能，从而使得我们开发人员可以忽略这些细节，关注更高级的功能。
* ArrayBlockingQueue
有界阻塞队列，内部实现是一个数组。有界的意思是它的容量是有限的，我们必须在其初始化的时候
指定它的容量大小，这个大小一般指定了就不能再变了。ArrayBlockingQueue是以先进先出的方式
处理数据，最先插入的数据在尾部，最新移除的对象是头部
* DelayQueue
阻塞的是内部元素，DelayQueue内部的元素必须实现一个接口J.U.C中的Delayed接口，这个Delayed
继承了Comparable接口，这是因为DelayQueue中的元素需要进行排序，一般情况下我们都是按照元素
过期时间的优先级进行排序。
  - 应用场景
    * 定时关闭连接
    * 缓存对象
    * 超时处理
  - 内部实现 : 基于PriorityQueue和ReentrantLock
* LinkedBlockingQueue
LinkedBlockingQueue组件队列大小配置是可选的，如果初始化时指定了一个大小，那么它就是有边界
的，如果没有就是无边界的。所谓无边界就是使用了默认的最大的整型值，它的内部实现是一个链表。
除了内部实现结构不一样其他大部分和ArrayBlockingQueue一样。LinkedBlockingQueue也是以先进
先出的方式储存数据，最新插入的数据在尾部，最新移除的对象在头部。
* PriorityBlockingQueue
PriorityBlockingQueue是一个带优先级的阻塞队列。PriorityBlockingQueue是一个没有边界的
队列，但是它是有排序规则的，需要注意的是这个PriorityBlockingQueue是允许插入null的。如果
使用PriorityBlockingQueue插入的对象必须实现comparable接口。队列的优先级排序规则就是按照
对comparable接口的实现来定义的。我们可以从PriorityBlockingQueue中获得一个迭代器，但是
这个迭代器并不保证按照我们优先级的顺序进行迭代。
* SynchronousQueue
SynchronousQueue内部仅允许一个元素，当一个线程插入一个元素后就会被阻塞，除非这个元素被另一个
线程消费，因此我们称它为同步队列，它是一个无界非缓存的队列，它不存储元素，放入元素只有等待取走
元素之后才能放入。