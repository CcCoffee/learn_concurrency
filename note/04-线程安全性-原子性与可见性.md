# 线程安全性
当多个线程访问某个类时，不管运行时环境采用**何种调度方式**或者这些进程将如何交替执行，
并且在主调代码中**不需要任何额外的同步或协同**，这个类都能表现出**正确的行为**，那么就称这个类
时线程安全的
* 原子性 : 提供了**互斥访问**，同一时刻只能有一个线程来对它进行操作
* 可见性 : 一个线程对主内存的修改可以及时的被其他线程观察到
* 有序性 : 一个线程观察其他线程中的指令执行顺序，由于指令重排序的存在，该观察结果一般杂乱无序
> 即使是使用了类似AtomicInteger的线程安全类，但是如果调用代码写的线程不安全，最终的结果
也是线程不安全的。所以外部调用代码的书写也要保证线程安全。

## 1. 原子性

**原子操作是不能被线程中断机制中断的操作**，一旦操作开始，则它一定在可能的切换到其他线程之前执行
完毕。简而言之就是不能被中断的操作，**如赋值或return**。**在其执行过程中，不允许其他并行线程对
该变量进行读取和写入的操作。 如果发生竞争，则其他线程必须等待。**

### JVM规定

1. 对于读写**除long和double之外**的基本类型变量的简单操作，可以保证它们的原子性来操作内存，因为
JVM将long和double这样的64位的变量拆分成两个分离的32位来操作，这样很可能在一个读取和写入操作之间
切换到其它线程，从而导致错误的结果。

2. 类似a+=2的操作不具备原子性，因为在JVM中这个操作需要三个步骤：

   ```bash
   1）取出a
   2）计算a+2
   3）将计算结果写入内存
   ```

   在上述步骤之间很可能线程调度器中断，转向另一个任务，这个任务可能修改这个域，造成结果错误，所以
   这个操作不是原子性的。

   同样a++也不具备原子性。（注：在C++中以上这两种操作都是原子性的）

### 没有原子性产生的问题

当前线程执行中断，其他线程覆盖执行。参考JVM规定的第二点说明。

### 原子性 - atomic包
AtomicXXX类可以保证原子性(由Unsafe.compareAndSwapInt(var1, var2, var5, var5 + var4)保证,如果主存中的数据已经跟
工作内存的数据不一致，这份方法会返回false，只需要循环执行，直到返回true即可(也叫**自旋**)。这种CAS的方式能够使原本非原子的方法逻辑实现
最终的原子化，**从这个角度来说AtomicInteger更适合计数场景**),及变量在多个线程之间可见(源码中成员变量count使用volatile修饰)
#### AtomicInteger源码分析
AtomicInteger类中提供了incrementAndGet方法;
```java
class AtomicInteger{
    public final int incrementAndGet() {
        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;
    }
}
```
incrementAndGet方法又调用了Unsafe类的getAndAddInt方法
```java
class Unsafe{
    public final int getAndAddInt(Object var1, long var2, int var4) {
        int var5;
        do {
            var5 = this.getIntVolatile(var1, var2);
            // 问题: 这里如果其他线程改变类var5的值不会发生并发问题吗？
            // 分析: 假设执行2+1案例，对象var1在工作内存中的var2为被加数2，而var4为加数1。
            // var5为var1对象在主内存中的值2。如果此时其他线程改变了主存中的var5变为3，
            // 在执行compareAndSwapInt方法时首先判断var2==var5，然后猜测应该还会判断var5
            // 是否被改变，如果有则会因为数据不一致返回false，从而再次进入此循环。
            // 结论: CAS保证了不会有并发问题
        } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));
        return var5;
    }
}
```
* 参数：
    - Object var1：传进来的AtomicInteger对象
    - long var2：是传进来的值，当前要进行加一的值 (比如要进行2+1的操作, var2就是2)
    - int var4：是传进来的值，进行自增要加上的值 (比如要进行2+1的操作, var4就是1)
    - int var5:是通过调用底层的方法this.getIntVolatile(var1, var2);得到的底层当前的值
* 分析：
    ```bash
    while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4))：
    通过do{} while()不停的将当前对象的传进来的值和底层的值进行比较,
    如果相同就将底层的值更新为：var5+var4(加一的操作),
    如果不相同,就重新再从底层取一次值,然后再进行比较，这就是CAS的核心。
    ```
* 帮助理解：把AtomicInteger里面存的值看成是工作内存中的值.
把底层的值看成是主内存中的值。在多线程中，工作内存中的值和主内存中的值会出现不一样的情况。

#### AtomicLong与LongAdder
* AtomicLong与AtomicInteger基本相同
  - 缺点 : 对于高并发场景会造成大量失败重新while循环,效率不高。使用LongAdder代替
* LongAdder : 在低并发时效率与AtomicLong基本相同，高并发时由于原理不同性能也很高
  - 缺点 : 数据可能有些偏差
  - 适用场景 : 网站访问计数等不需要太精确的业务
  - 设计的思路 :
    
    AtomicLong中有个内部变量value保存着实际的long值，所有的操作都是针对该变量进行。也就是说，高并发环境下，value
    变量其实是一个热点，也就是N个线程竞争一个热点。LongAdder的基本思路就是**分散热点**，将value值分散到一个数组中，
    不同线程会命中到数组的不同槽中，各个线程只对自己槽中的那个值进行CAS操作，这样热点就被分散了，冲突的概率就小很多。
    如果要获取真正的long值，只要将各个槽中的变量值累加返回。ConcurrentHashMap中的“分段锁”其实就是类似的思路。
    
    LongAdder提供的API和AtomicLong比较接近，两者都能以原子的方式对long型变量进行增减。但是AtomicLong提供的功能
    其实更丰富，尤其是addAndGet、decrementAndGet、compareAndSet这些方法。addAndGet、decrementAndGet除了单纯的
    做自增自减外，还可以立即获取增减后的值，而LongAdder则需要做同步控制才能精确获取增减后的值。如果业务需求需要精确的
    控制计数，做计数比较，AtomicLong也更合适。
    
    另外，从空间方面考虑，LongAdder其实是一种“空间换时间”的思想，从这一点来讲AtomicLong更适合。当然，如果你一定要跟
    我杠现代主机的内存对于这点消耗根本不算什么，那我也办法。
* 如何选用AtomicLong与AtomicInteger？

  低并发、一般的业务场景下AtomicLong是足够了。如果并发量很多，存在大量写多读少的情况，那LongAdder可能更合适。
  适合的才是最好的，如果真出现了需要考虑到底用AtomicLong好还是LongAdder的业务场景，那么这样的讨论是没有意义的，因为
  这种情况下要么进行性能测试，以准确评估在当前业务场景下两者的性能，要么换个思路寻求其它解决方案。

参考 : https://segmentfault.com/a/1190000015865714
#### * AtomicReference
AtomicLong与AtomicInteger仅能保证一个变量的原子性。当我们需要**修改多个变量**时要把相关变量封装成
AtomicReference类型的对象。

```java
class AtomicReference {
    public final boolean compareAndSet(V expect, V update) {
        return unsafe.compareAndSwapObject(this, valueOffset, expect, update);
    }
}
```
主要的作用是通过比对主存中的对象与expect的对象是否`==`（即引用指向同一个内存地址），然后更新为新的对象

```java
class Test {
    public void atomicString() throws InterruptedException {
        AtomicReference<String> stringAtomicReference = new AtomicReference<>();
        stringAtomicReference.set("");
        Semaphore semaphore = new Semaphore(50);// 最大并发量为50
        int totalCount = 5000; // 总线程数
        CountDownLatch countDownLatch = new CountDownLatch(totalCount);
        ExecutorService executorService = Executors.newCachedThreadPool();
        for (int i = 0; i < totalCount; i++) {
            executorService.execute(()->{
                try {
                    semaphore.acquire();
                    // 采用死循环，线程过多时碰撞变多，性能变差
                    while (true) {
                        String oldString = stringAtomicReference.get();
                        String newString = oldString.concat("a"); // 局部变量时线程安全的
                        if(stringAtomicReference.compareAndSet(oldString, newString)){
                            break;
                        }
                    }
                    semaphore.release();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                countDownLatch.countDown();
            });
        }
        countDownLatch.await();
        executorService.shutdown();
        log.info("length = {}", stringAtomicReference.get().length());
    }
}
```

#### * AtomicIntegerFieldUpdater
用于线程安全的更新实例对象的某个属性值
一般仅使用`boolean compareAndSet(V expect, V update)`
> 很少使用

#### AtomicStampedReference与CAS中的ABA问题

* 描述：在CAS操作时，其他线程将变量的值从A改成了B,然后又将B改回了A。
* 解决思路：每次变量改变时，将变量的版本号加1,只要变量被修改过，变量的版本号就会发生递增变化
* 调用compareAndSet方法：
```java
class AtomicStampedReference{
    public boolean compareAndSet(V expectedReference, V newReference,
                                 int expectedStamp, int newStamp) {
        Pair<V> current = pair;
        return
            expectedReference == current.reference &&
            expectedStamp == current.stamp &&
            ((newReference == current.reference &&
              newStamp == current.stamp) ||
             casPair(current, Pair.of(newReference, newStamp)));
    }
}
```
stamp是每次更新时就维护的， 通过对比来判断是不是一个版本号，expectedStamp == current.stamp

#### AtomicLongArray
与AtomicLong类似，用于操作数组，所有操作需要加上一个index用于索引
```java
class AtomicLongArray {
    public final long incrementAndGet(int i) {
        return getAndAdd(i, 1) + 1;
    }
}
```

#### AtomicBoolean
使用场景 : 让代码只执行一次

### CAS的缺陷
#### 1.循环开销大
可以看到，方法内部用不断循环的方式实现修改。如果CAS长时间一直不成功，可能会给CPU带来很大的开销。

##### 解决方案
* 破坏掉for死循环，当超过一定时间或者一定次数时，return退出。JDK8新增的LongAddr,和
ConcurrentHashMap类似的方法。当多个线程竞争时，将粒度变小，将一个变量拆分为多个变量，达到多个
线程访问多个资源的效果，最后再调用sum把它合起来。
* 如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：第一，它可以
延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，
在一些处理器上延迟时间是零；第二，它可以避免在循环的时候因内存顺序冲突（Memory Order Violation）
而引起CPU流水线被清空，从而提高CPU的实行效率。
#### 2.只能保证一个共享变量的原子操作
需要对多个共享变量操作时，循环CAS就无法保证操作的原子性。

##### 解决方案
* 用锁
* 把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i=2,j=a,合并一下ji=2a,然后用CAS来
操作ij。
* 封装成对象。注：从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之前的原子性，可以把
多个变量放在一个对象里来进行CAS操作。
#### 3.ABA问题
CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成
了B，又变成了A，那么CAS进行检查的时候发现它的值没有发生变化，但是实质上它已经发生了改变 。可能会
造成数据的缺失。

##### 解决方案
CAS类似于乐观锁，即每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下
在此期间别人有没有去更新这个数据。因此解决方案也可以跟乐观锁一样：

* 使用版本号机制，如手动增加版本号字段
* Java 1.5开始，JDK的Atomic包里提供了一个类`AtomicStampedReference`来解决ABA问题。这个类的
compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前的标志是否等于预期标志，
如果全部相等，则以原子方式将该应用和该标志的值设置为给定的更新值。

### 原子性 - 同步锁
#### 原子性 - synchronized
* synchronized:**依赖JVM**
  * synchronized修饰的对象有四种：
    1. 修饰代码块：作用范围是大括号括起来的代码，作用于调用的对象
       * `synchronized(this) {}`
    2. 修饰方法：作用范围是整个方法，作用于调用的对象
       * `public synchronized void test()`
    3. 修饰静态方法：作用范围是整个静态的方法，作用于这个类的所有对象
       * `public static synchronized void test()`
    4. 修饰类：作用范围是synchronized括号括起来的部分，作用于这个类的所有对象
       * `synchronized(Example.class)`
  * 子类无法继承父类的synchronized关键字，因为synchronized不属于方法声明的一部分
#### 原子性 - lock

### synchronized、lock与Atomic的对比
* synchronized : 不可中断锁，一旦代码执行到作用范围之内必须等待代码执行完的，
适合竞争不激烈， 可读性好
* lock : 可中断锁，多样化同步，竞争激烈时能维持常态
* Atomic : 竞争激烈时能维持常态，**比Lock性能好**；**只能同步一个值**，而不是代码块

## 2. 可见性
参考: https://www.cnblogs.com/yaowen/p/11240540.html
```bash
可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
```

### 没有可见性产生的问题

如果线程t1与线程t2分别被安排在了不同的处理器上面，那么t1与t2对于变量A的修改时相互不可见，如果t1
给A赋值，然后t2又赋新值，那么t2的操作就将t1的操作覆盖掉了，这样会产生不可预料的结果。所以，**即使
有些操作是原子性的，但是如果不具有可见性，那么多个处理器中备份的存在就会使原子性失去意义**。

(ps:原子性应该只是读和计算，而没有写入主内存）

* 导致共享变量在线程间不可见的原因
    - 线程交叉执行
    - 重排序结合线程交叉执行
    - 共享变量更新后的值没有在工作内存与主存间及时更新
### 可见性 - synchronized
* JMM关于synchronized的两条规定
    - 线程*解锁*前，必须把共享变量的最新值刷新到主内存
    - 线程*加锁*时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值
（注意，加锁与解锁是同一把锁。synchronized修饰方法的前两条是对于调用对象的，
对于不同对象其实锁的范围是不一样的，如果不是同一把锁他们之间是不会互相影响的）
> 正因为synchronized的可见性以及原子性，因此在线程安全同步的时候只要使用synchronized
进行修饰之后变量就可以放心进行使用
### volatile
* 定义 : volatile是“轻量级”synchronized，通过加入**内存屏障**和**禁止重排序**优化来保证了共享
变量的“可见性”（JMM确保所有线程看到这个变量的值是一致的)
  - 当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知
  其他CPU将该变量的缓存行置为无效状态并且锁住缓存行，因此当其他CPU需要读取这个变量时，要等锁释放，
  并发现自己缓存行是无效的，那么它就会从内存重新读取。
  - 使用和执行成本比synchronized低，因为它不会引起线程上下文切换和调度。

#### volatile的特性 - 可见性

#### volatile的特性 - 禁止重排序

```bash
普通变量仅仅会保证在单线程的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值
操作的顺序与程序代码中的执行顺序一致。我们在单线程的执行过程中是无法感知到这点，这也就是java 内存
模型中描述的所谓的 “线程内表现为串行的语义”。
```

【指令重排序演示（伪代码）】

```bash


        Map configOptions;  
        char[] configText;  
        //  此变量必须为 volatile  
        volatile boolean initialized = false;  

        1，// 假设以下代码在线程A 中执行  
        // 模拟读取配置信息，当读取完成后将 initialized 设置为true 已通知其他线程配置可用  
        configOptions = new HashMap();  
        configText = readConfigFile(filename);  
        processConfigOptions(configText, configOptions);  
        initialized = true;  

        2，// 假设以下代码在线程B 中执行  
        // 等待initialized 为true，代表线程A 已经把配置信息初始化完成  
        while(!initialized) {  
            sleep();  
        }  
        // 使用线程A 中初始化好的配置信息  
        doSomethingWithConfig();  
    }
```

如果定义initialized变量没有使用volatile修饰：就可能会由于指令重排序的优化，导致位于线程A 中最后
一句码initialized=true被提前执行（即这行代码对应的汇编代码被提前执行），这样在线程B中使用配置信息
的代码就可能出现错误（获取时还没有初始化配置），而volatile关键字则可以避免此类情况的发生。

#### 内存屏障

```bash
因为缓存导致的可见性和,cpu/编译期重排序执行优化可能导致错误。
不同的处理器重排序的规则也是不一样的。
java内存模型为了避免这种差异造成的问题，通过内存屏障方式来实现可见见性和非重排序。

常见的有2种方式：
1，通过 Synchronized关键字包住的代码区域,插入了StoreStore屏障
2，使用了volatile修饰变量,则对变量的写操作,会插入StoreLoad屏障.

不常用的，通过Unsafe这个类来执行.
UNSAFE.putOrderedObject类似这样的方法,会插入StoreStore内存屏障 
Unsafe.putVolatiObject 则是插入了StoreLoad屏障
```

##### 1. 硬件层内存屏障

* 作用
  1. 阻止屏障两侧的指令重排序；
  2. 强制把写缓冲区/高速缓存中的脏数据等写回主内存，让缓存中相应的数据失效。
* 分类
  - Load Barrier : 在指令前插入Load Barrier，可以让高速缓存中的数据失效，强制从新从主内存加载新数据
  - Store Barrier : 在指令后插入Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见
##### 2. Java内存屏障

* 定义 : 内存屏障，又称内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制。
* 内存屏障的作用：
  1. 在有内存屏障的地方，会禁止指令重排序，即屏障下面的代码不能跟屏障上面的代码交换执行顺序。
  2. 在有内存屏障的地方，线程修改完共享变量以后会马上把该变量从本地内存写回到主内存，并且让其他
  线程本地内存中该变量副本失效（使用MESI协议）
* 分类
  - LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据
  被访问前，保证Load1要读取的数据被读取完毕。
  - StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，
  保证Store1的写入操作对其它处理器可见。
  - LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，
  保证Load1要读取的数据被读取完毕。
  - StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，
  保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。
    * 在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。
##### 3. volatile语义中的内存屏障

* 对volatile变量*写操作*时，会在写操作后加入一条store屏障指令，将本地内存中的变量值
刷新到主内存
* 对volatile变量*读操作*时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量

* volatile的内存屏障策略非常严格保守，非常悲观且毫无安全感的心态。
  下面是基于保守策略的JMM内存屏障插入策略：
  - 在每个volatile写操作的前面插入一个StoreStore屏障。
  - 在每个volatile写操作的后面插入一个StoreLoad屏障。
  - 在每个volatile读操作的前面插入一个LoadLoad屏障。
  - 在每个volatile读操作的后面插入一个LoadStore屏障。
* 图示
<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb815cp2taj30kw0csgp6.jpg" alt="image-20200124224031757" style="zoom:70%;" />
<img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gb816ifuiyj30ko0csn0s.jpg" alt="image-20200124224138172" style="zoom:70%;" />

#### volatile的实现原理

通过对OpenJDK中的unsafe.cpp源码的分析，会发现被volatile关键字修饰的变量会存在一个“lock:”的前缀。
Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能。
Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。类似于Lock指令。
在具体的执行上，它先对总线和缓存加锁，然后执行后面的指令，在Lock锁住总线的时候，
其他CPU的读写请求都会被阻塞，直到锁释放。最后释放锁后会把高速缓存中的脏数据全部刷新回主内存，
且这个写回内存的操作会使在其他CPU里缓存了该地址的数据无效。

#### volatile的作用
1. 锁总线，其它CPU对内存的读写请求都会被阻塞，直到锁释放，不过实际后来的处理器都采用锁缓存替代锁
总线，因为锁总线的开销比较大，锁总线期间其他CPU没法访问内存
2. lock后的写操作会回写已修改的数据，同时让其它CPU相关缓存行失效，从而重新从主存中加载最新的数据
3. 不是内存屏障却能完成类似内存屏障的功能，阻止屏障两遍的指令重排序（通过“lock:”的前缀）
4. 当对long和double类型的变量用关键字volatile修饰时，就能获得简单操作**赋值**和**return**的
原子性。
> 但除对long和double简单类型的简单操作外，volatile并不能提供原子性，即使对一个变量用volatile修饰，
对这个变量的操作也不是原子性的。
#### 适用场景
* 使用场景1 : 作为状态标记量
  - 使用volatile必须具备两个条件
    * 运算结果并不依赖变量的当前值，或者能确保只有单一的线程修改变量的值。
    * 变量不需要与其他的状态变量共同参与不变约束。
    
  - 例子1：当init被赋值为true，while循环能够立即结束
    ```java
    class Example {
        public void test(){
            volatile boolean init = false; //init用来标识线程初始化是否完成
            //线程一：  线程一负责初始化
            context = loadContext(); //初始化操作
            init = true;//初始化完成后修改状态
        
            //线程二:  线程二必须保证初始化完成才能执行
            while(!init){//所以线程二不断的判断是否为init是否true，只有为true时，线程二才开始执行
                sleep();
            }
            doSomethingWithConfig(context);
        }
    }
    ```
    
  - 例子2
  
    ```java
    // 使用volatile变量来控制并发  
    public class VolatileVariableTest {  
        volatile boolean shutdownRequested; // volatile变量  
    
        public void shutdown() {  
            shutdownRequested = true;  
        }  
        public void doWork() {  
            while(!shutdownRequested) {  
                // do sth.  
            }  
        }
    }
    ```
  
* 使用场景2 : 用来双重检测，单例模式中的双重检测机制

#### 对于 long 和 double 型变量的规则

**（1）64位数据类型的非原子性协定**

Java内存模型要求lock， unlock， read， load， assign， use，store，write这8个操作都具有
原子性，但对于64位的数据类型（long和double），在模型中特别定义了一条相对宽松的规定：

允许虚拟机将没有被 volatile 修饰的64位数据的读写操作划分为 两次 32位的操作来进行，即允许虚拟机
实现选择可以不保证64位数据类型的 load， store，read和write 这4个操作的原子性，这点就是所谓的
 long 和double 的非原子性协定（Nonatomic Treatment of double and long Variable）。

**（2）非原子性协定导致的问题**

如果有多个线程共享一个并未声明为 volatile的 long 或 double类型的变量，并且同时对它们进行读取和
修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了“半个变量”的数值。

**（3）“半个变量”的情况**

不过这种读取到的“半个变量”的情况非常罕见（商业JVM中尚未出现）：因为Java内存模型虽然允许虚拟机不把
long 和 double 变量的读写实现成原子操作，但允许虚拟机选择把 这些操作实现为具有原子性的操作，而且
还强烈建议虚拟机这样实现。实际开发中，目前各平台下的商用虚拟机几乎选择把64位数据读写操作作为原子
操作来对待，因此平时编写代码时不需要把long 和 double 变量专门声明为 volatile。

参考 : https://blog.csdn.net/q2878948/article/details/90105951
